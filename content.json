{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"Aran.Hu","url":"http://yoursite.com"},"pages":[{"title":"","date":"2018-07-04T17:15:24.000Z","updated":"2018-07-04T17:15:24.000Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"","date":"2018-07-04T17:15:24.000Z","updated":"2018-07-04T17:15:24.000Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"javascript-函数式编程","slug":"javascript-函数式编程","date":"2017-03-28T15:00:19.000Z","updated":"2018-07-05T15:57:23.000Z","comments":true,"path":"2017/03/28/javascript-函数式编程/","link":"","permalink":"http://yoursite.com/2017/03/28/javascript-函数式编程/","excerpt":"javascript-函数式编程 描述 函数式编程函数式编程函数式编程函数式编程","text":"javascript-函数式编程 描述 函数式编程函数式编程函数式编程函数式编程","categories":[],"tags":[]},{"title":"rn-键盘遮挡问题","slug":"rn-键盘遮挡问题","date":"2017-03-28T14:35:37.000Z","updated":"2018-07-04T17:15:24.000Z","comments":true,"path":"2017/03/28/rn-键盘遮挡问题/","link":"","permalink":"http://yoursite.com/2017/03/28/rn-键盘遮挡问题/","excerpt":"rn-键盘遮挡问题 1、KeyboardAvoidingView2、DeviceEventEmitter(隐藏API系列)","text":"rn-键盘遮挡问题 1、KeyboardAvoidingView2、DeviceEventEmitter(隐藏API系列)1234567891011121314151617181920212223242526constructor (props)&#123; super(props); DeviceEventEmitter.addListener('keyboardWillShow', this.keyboardWillShow.bind(this)); DeviceEventEmitter.addListener('keyboardWillHide', this.keyboardWillHide.bind(this)); &#125; keyboardWillShow (e)&#123; this.commentView &amp;&amp; this.commentView.setNativeProps(&#123; style: &#123; height: commentHeight - e.endCoordinates.height &#125; &#125;) &#125; keyboardWillHide ()&#123; this.commentView &amp;&amp; this.commentView.setNativeProps(&#123; style: &#123; height: commentHeight &#125; &#125;) &#125; componentUnMount()&#123; this.keyboardWillHideEvent.remove() this.keyboardWillShowEvent.remove() &#125; 描述","categories":[],"tags":[]},{"title":"nodejs-异步与单线程","slug":"nodejs-异步与单线程","date":"2017-03-28T14:31:26.000Z","updated":"2018-07-04T17:15:24.000Z","comments":true,"path":"2017/03/28/nodejs-异步与单线程/","link":"","permalink":"http://yoursite.com/2017/03/28/nodejs-异步与单线程/","excerpt":"Title 描述 http://www.cnblogs.com/dolphinX/p/3475090.html","text":"Title 描述 http://www.cnblogs.com/dolphinX/p/3475090.html","categories":[],"tags":[{"name":"node.js","slug":"node-js","permalink":"http://yoursite.com/tags/node-js/"}]},{"title":"react","slug":"react","date":"2017-03-23T14:50:16.000Z","updated":"2018-07-04T17:15:24.000Z","comments":true,"path":"2017/03/23/react/","link":"","permalink":"http://yoursite.com/2017/03/23/react/","excerpt":"Title 描述","text":"Title 描述","categories":[],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"}]},{"title":"javascript-编译原理","slug":"javascript-编译原理","date":"2017-03-23T14:46:05.000Z","updated":"2018-07-04T17:15:24.000Z","comments":true,"path":"2017/03/23/javascript-编译原理/","link":"","permalink":"http://yoursite.com/2017/03/23/javascript-编译原理/","excerpt":"javascript-编译原理 描述","text":"javascript-编译原理 描述","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"javascript-指针","slug":"javascript-指针","date":"2017-03-23T14:45:51.000Z","updated":"2018-07-04T17:15:24.000Z","comments":true,"path":"2017/03/23/javascript-指针/","link":"","permalink":"http://yoursite.com/2017/03/23/javascript-指针/","excerpt":"javascript-指针 描述","text":"javascript-指针 描述","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"javascript-闭包","slug":"javascript-闭包","date":"2017-03-23T14:42:01.000Z","updated":"2018-07-04T17:15:24.000Z","comments":true,"path":"2017/03/23/javascript-闭包/","link":"","permalink":"http://yoursite.com/2017/03/23/javascript-闭包/","excerpt":"JavaScript闭包 描述","text":"JavaScript闭包 描述","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"RN-原生组件封装-IOS","slug":"rn-原生组件封装-ios","date":"2017-03-20T13:47:37.000Z","updated":"2018-07-04T17:15:24.000Z","comments":true,"path":"2017/03/20/rn-原生组件封装-ios/","link":"","permalink":"http://yoursite.com/2017/03/20/rn-原生组件封装-ios/","excerpt":"原生模块封装-IOSDemops: 还是得自己过坑😁 1、创建一个用来调试模块的RN项目 2、在项目的node_module目录下创存放组件的目录比如A 3、XCODE打开RN项目中的IOS项目, 完成原生模块的封装及测试 4、封装完成后, 使用XCODE在目录A中创建静态库项目(模块名称最好和上面调试模块的名称一致)","text":"原生模块封装-IOSDemops: 还是得自己过坑😁 1、创建一个用来调试模块的RN项目 2、在项目的node_module目录下创存放组件的目录比如A 3、XCODE打开RN项目中的IOS项目, 完成原生模块的封装及测试 4、封装完成后, 使用XCODE在目录A中创建静态库项目(模块名称最好和上面调试模块的名称一致) 5、把RN-&gt;IOS项目中封装模块的代码.h.m拷贝到静态库文件中 6、设置静态库项目的header search path路径(添加React的依赖) 1Build Settings-&gt;Header Search Patchs-&gt;$(SRCROOT)/../../react-native/React -&gt; recursive 注意： 1 如果是别人的库，按照要求添加应该就OK 2 自己开发的库如果出现找不到React相关依赖时，查看引用路径，或组件导出输出路径是否正确(90%是这的问题) 3 可直接在依赖静态库中更改Search Paths TODO 更多原生事件等","categories":[{"name":"前端开发","slug":"前端开发","permalink":"http://yoursite.com/categories/前端开发/"}],"tags":[{"name":"react-native","slug":"react-native","permalink":"http://yoursite.com/tags/react-native/"}]},{"title":"RN-原生组件封装-Android","slug":"rn-原生组件封装-android","date":"2017-03-20T13:47:29.000Z","updated":"2018-07-04T17:15:24.000Z","comments":true,"path":"2017/03/20/rn-原生组件封装-android/","link":"","permalink":"http://yoursite.com/2017/03/20/rn-原生组件封装-android/","excerpt":"原生模块封装-ANDROID Demoref:1 2 3 ps: 还是得自己过坑😁 1、用Android Studio打开创建RN项目中的Android项目(比如成为A) 2、在A的根目录中新建一个Module(右键或者File -&gt; New -&gt; New Module)，这里称为BModule 3、在B中添加自己要封装的模块比如Toast的实现 4、B中的依赖要和母RN项目一致或不要过高(有警告) 5、引用的话就直接react-native link","text":"原生模块封装-ANDROID Demoref:1 2 3 ps: 还是得自己过坑😁 1、用Android Studio打开创建RN项目中的Android项目(比如成为A) 2、在A的根目录中新建一个Module(右键或者File -&gt; New -&gt; New Module)，这里称为BModule 3、在B中添加自己要封装的模块比如Toast的实现 4、B中的依赖要和母RN项目一致或不要过高(有警告) 5、引用的话就直接react-native link 注意：封装组件时候尽量保持如下目录(图1); 引用时候路径 12include &apos;:aran-native-log&apos;project(&apos;:aran-native-log&apos;).projectDir = new File(rootProject.projectDir, &apos;../node_modules/aran-native-log/android&apos;) Alt text 图一 TODO 更多原生事件等","categories":[{"name":"前端开发","slug":"前端开发","permalink":"http://yoursite.com/categories/前端开发/"}],"tags":[{"name":"react-native","slug":"react-native","permalink":"http://yoursite.com/tags/react-native/"}]},{"title":"js-es6","slug":"js-es6","date":"2017-03-12T15:29:51.000Z","updated":"2018-07-04T17:15:24.000Z","comments":true,"path":"2017/03/12/js-es6/","link":"","permalink":"http://yoursite.com/2017/03/12/js-es6/","excerpt":"Title 描述","text":"Title 描述","categories":[{"name":"前端开发","slug":"前端开发","permalink":"http://yoursite.com/categories/前端开发/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"js-basic","slug":"js-basic","date":"2017-03-12T15:29:39.000Z","updated":"2018-07-04T17:15:24.000Z","comments":true,"path":"2017/03/12/js-basic/","link":"","permalink":"http://yoursite.com/2017/03/12/js-basic/","excerpt":"Title 描述","text":"Title 描述","categories":[{"name":"前端开发","slug":"前端开发","permalink":"http://yoursite.com/categories/前端开发/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"RN-Promotion","slug":"rn-promotion","date":"2017-03-12T15:09:28.000Z","updated":"2018-07-04T17:15:24.000Z","comments":true,"path":"2017/03/12/rn-promotion/","link":"","permalink":"http://yoursite.com/2017/03/12/rn-promotion/","excerpt":"RN-记录的组件 项目中一些组件的实现及相关实践","text":"RN-记录的组件 项目中一些组件的实现及相关实践 日历自定义Scrollview下拉动画滚动广告区域滚动数字收益曲线图及动画手势解锁##","categories":[{"name":"前端开发","slug":"前端开发","permalink":"http://yoursite.com/categories/前端开发/"}],"tags":[{"name":"react-native","slug":"react-native","permalink":"http://yoursite.com/tags/react-native/"}]},{"title":"rn-communication-fundamentals","slug":"rn-communication-fundamentals","date":"2017-03-11T15:04:05.000Z","updated":"2018-07-04T17:15:24.000Z","comments":true,"path":"2017/03/11/rn-communication-fundamentals/","link":"","permalink":"http://yoursite.com/2017/03/11/rn-communication-fundamentals/","excerpt":"Title 描述","text":"Title 描述","categories":[{"name":"前端开发","slug":"前端开发","permalink":"http://yoursite.com/categories/前端开发/"}],"tags":[{"name":"react-native","slug":"react-native","permalink":"http://yoursite.com/tags/react-native/"}]},{"title":"RN-Gesture","slug":"rn-gesture-usage","date":"2017-03-11T15:01:44.000Z","updated":"2018-07-04T17:15:24.000Z","comments":true,"path":"2017/03/11/rn-gesture-usage/","link":"","permalink":"http://yoursite.com/2017/03/11/rn-gesture-usage/","excerpt":"Title 描述","text":"Title 描述","categories":[],"tags":[]},{"title":"rn-f8app","slug":"rn-f8app","date":"2017-03-11T14:58:10.000Z","updated":"2018-07-04T17:15:24.000Z","comments":true,"path":"2017/03/11/rn-f8app/","link":"","permalink":"http://yoursite.com/2017/03/11/rn-f8app/","excerpt":"Title 描述","text":"Title 描述","categories":[],"tags":[]},{"title":"RN-Animation","slug":"rn-animation-usage","date":"2017-03-11T14:53:46.000Z","updated":"2018-07-04T17:15:24.000Z","comments":true,"path":"2017/03/11/rn-animation-usage/","link":"","permalink":"http://yoursite.com/2017/03/11/rn-animation-usage/","excerpt":"ReactNative AnimationInteractionManager 这里提及InteractionManager是因为InteractionManager的使用可以帮助我们实现更好的动画交互 几种动画交互优化的实现 InteractionManager //通常用于场景切换时的过场动画和异步数据加载 requestAnimationFrame(): 用来执行在一段时间内控制视图动画的代码 setImmediate/setTimeout/setInterval(): 在稍后执行代码。注意这有可能会延迟当前正在进行的动画。 runAfterInteractions(): 在稍后执行代码，不会延迟当前进行的动画。","text":"ReactNative AnimationInteractionManager 这里提及InteractionManager是因为InteractionManager的使用可以帮助我们实现更好的动画交互 几种动画交互优化的实现 InteractionManager //通常用于场景切换时的过场动画和异步数据加载 requestAnimationFrame(): 用来执行在一段时间内控制视图动画的代码 setImmediate/setTimeout/setInterval(): 在稍后执行代码。注意这有可能会延迟当前正在进行的动画。 runAfterInteractions(): 在稍后执行代码，不会延迟当前进行的动画。 第三种实测无太大影响，但尽量避免并行动画时使用setTimeout(由于其不确定性，有可能导致动画执行顺序更改) 1、用法 123456789InteractionManager.runAfterInteractions(() =&gt; &#123; // ...耗时较长的同步的任务...&#125;);var handle = InteractionManager.createInteractionHandle();// 执行动画... (`runAfterInteractions`中的任务现在开始排队等候)// 在动画完成之后 执行动画的方法机会写在这个中间就行了InteractionManager.clearInteractionHandle(handle);// 在所有句柄都清除之后，现在开始依序执行队列中的任务 runAfterInteractions接受一个普通的回调函数，或是一个PromiseTask对象，该对象需要带有名为gen的方法，并返回一个Promise。如果提供的参数是一个PromiseTask， 那么即便它是异步的它也会阻塞任务队列，直到它（以及它所有的依赖任务，哪怕这些依赖任务也是异步的）执行完毕后，才会执行下一个任务。 默认情况下，排队的任务会在一次setImmediate方法中依序批量执行。如果你调用了setDeadLine方法并设定了一个正整数值，则任务只会在设定的时间到达后开始执行。在此之前，任务会通过setTimeout来挂起并阻塞其他任务执行，这样可以给诸如触摸交互一类的事件留出时间，使应用可以更快地响应用户。 runAfterInteractions(callback: Function) 安排一个函数在所有的交互和动画完成之后运行。返回一个可取消的promise。 createInteractionHandle() 通知管理器有某个动画或者交互开始了。 clearInteractionHandle(handle: Handle) 通知管理器有某个动画或者交互已经结束了。 setDeadline(deadline: number) 如果设定了一个正整数值，则会使用setTimeout来挂起所有尚未执行的任务。在eventLoopRunningTime到达设定时间后，才开始使用一个setImmediate方法来批量执行所有任务。 2、属性 Events addListener 1234567891011121314151617// jest中的示例用法，自己并未具体实现beforeEach(() =&gt; &#123; jest.resetModules(); InteractionManager = require(&apos;InteractionManager&apos;); interactionStart = jest.fn(); interactionComplete = jest.fn(); InteractionManager.addListener( InteractionManager.Events.interactionStart, interactionStart ); InteractionManager.addListener( InteractionManager.Events.interactionComplete, interactionComplete );&#125;); Animations1、 LayoutAnimation LayoutAnimation 神器😁。 允许你在全局范围内创建和更新动画，这些动画会在下一次渲染或布局周期运行 1234//android UIManager.setLayoutAnimationEnabledExperimental &amp;&amp; UIManager.setLayoutAnimationEnabledExperimental(true);//在需要的地方设置当前页面动画LayoutAnimation.configureNext(LayoutAnimation.Presets.spring); easeInEaseOut //缓入缓出 linear //线性 spring //弹跳 easeIn //缓入 easeOut //缓出 keyboard //键入 也可以自定义动画效果 2、Animated.Value 最基本的一个动画使用方式是创建一个Animated.Value,将该动画绑定到一个或者多个样式属性到动画组件中，然后通过开启动画运行 12345678this.state = &#123;bounceValue: new Animated.Value(0),&#125;Animated.spring( this.state.bounceValue, &#123; toValue: 0.8, friction: 1 &#125;).start(); // 东西略多。。。 0 1 2","categories":[{"name":"前端开发","slug":"前端开发","permalink":"http://yoursite.com/categories/前端开发/"}],"tags":[{"name":"react-native","slug":"react-native","permalink":"http://yoursite.com/tags/react-native/"}]},{"title":"RN-混合开发","slug":"rn-mixeddevelopment","date":"2017-03-11T13:20:34.000Z","updated":"2018-07-04T17:15:24.000Z","comments":true,"path":"2017/03/11/rn-mixeddevelopment/","link":"","permalink":"http://yoursite.com/2017/03/11/rn-mixeddevelopment/","excerpt":"RN集成到原生项目 集成是双向的，RN很好的解决了这个问题。原生项目中使用RN开发还是很方便的。 IOS原生混和开发：一、开发配置 参考 1. IOS项目中搭建RN开发环境(见参考)2. 创建package.json","text":"RN集成到原生项目 集成是双向的，RN很好的解决了这个问题。原生项目中使用RN开发还是很方便的。 IOS原生混和开发：一、开发配置 参考 1. IOS项目中搭建RN开发环境(见参考)2. 创建package.json 12345678910111213&#123; &quot;name&quot;: &quot;MyRNApp&quot;, &quot;version&quot;: &quot;0.0.1&quot;, &quot;private&quot;: true, &quot;scripts&quot;: &#123; &quot;start&quot;: &quot;node node_modules/react-native/local-cli/cli.js start&quot; &#125;, &quot;dependencies&quot;: &#123; &quot;react&quot;: &quot;15.2.1&quot;, &quot;react-native&quot;: &quot;0.31.0&quot; &#125;&#125;====&gt; npm install 3. 安装CocoaPods123456789101112131415161718192021222324252627282930313233343536373839# Uncomment this line to define a global platform for your project# platform :ios, '9.0'target 'MyRNApp' do # Uncomment this line if you're using Swift or would like to use dynamic frameworks # use_frameworks! # Pods for MyRNApp pod 'React', :path =&gt; 'node_modules/react-native', :subspecs =&gt; [ 'ART', 'RCTActionSheet', 'RCTAdSupport', 'RCTGeolocation', 'RCTImage', 'RCTNetwork', 'RCTPushNotification', 'RCTSettings', 'RCTText', 'RCTVibration', 'RCTWebSocket', 'RCTLinkingIOS' # Add any other subspecs you want to use in your project ] target 'MyRNAppTests' do inherit! :search_paths # Pods for testing end target 'MyRNAppUITests' do inherit! :search_paths # Pods for testing endend注意path的路径设置,默认根目录,也可文件夹中====&gt; pod install 喽~ 二、开始开发1. 创建index.ios.js12345678910111213141516171819&apos;use strict&apos;;import React, &#123;Component&#125; from &apos;react&apos; import &#123; Text, View, AppRegistry&#125; from &apos;react-native&apos;; class NativeRNApp extends React.Component &#123; render() &#123; return ( &lt;View &gt; &lt;Text&gt;This is a simple application.&lt;/Text&gt; &lt;/View&gt; ) &#125;&#125;AppRegistry.registerComponent(&apos;NativeRNApp&apos;, () =&gt; NativeRNApp); 2. 设置JS入口 注: 可以直接就设置到默认的ViewController,也可以自己写个ReactViewController 1234567891011121314151617181920212223@implementation ViewController - (void)viewDidLoad &#123; [super viewDidLoad]; [self initRNView]; &#125; - (void)didReceiveMemoryWarning &#123; [super didReceiveMemoryWarning];&#125; -(void)initRNView &#123; NSString * strUrl = @\"http://localhost:8081/index.ios.bundle?platform=ios&amp;dev=true\"; NSURL * jsCodeLocation = [NSURL URLWithString:strUrl]; RCTRootView * rootView = [[RCTRootView alloc] initWithBundleURL:jsCodeLocation moduleName:@\"NativeRNApp\" initialProperties:nil launchOptions:nil]; self.view = rootView;&#125; ===&gt; moduleName:@\"NativeRNApp\" 注意这个名称要和index.ios.js 中的对应上 3. 一些问题记录 参考 报错: App Transport Security has blocked a cleartext HTTP (http://) resource load since it is insecure 报错原因是需要开启内网http的访问权限（iOS9之后会有这个问题）。 在Info.plist中添加 NSAppTransportSecurity 类型 Dictionary ;在 NSAppTransportSecurity 下添加 NSAllowsArbitraryLoads 类型Boolean ,值设为 YES;参考地址： - 报错：RCTStatusBarManager module requires that the UIViewControllerBasedStatusBarAppearance key in the Info.plist is set to NO 错误信息说的很清楚了。 在Info.plist中添加View controller-based status bar appearance为NO。http://www.cnblogs.com/chglog/p/4746683.html Markdown 应该还要在项目中设置node_modules的查找路径的…忘了在哪设置的了 集成已有RN模块(jsbundle)： RN的项目直接作为模块嵌入到已有项目中 一、开发配置 同上 二、开始开发2-1 RNApp 打包jsbundle及资源文件 参考 打包： (仅JS) react-native bundle –parameter ios –entry-file index.ios.js –bundle-output ./testCodePush/APP_task010001.js (包含图片等资源) react-native bundle –parameter ios –entry-file index.ios.js –bundle-output ./bundles/SwitchCheck010004.js –assets-dest ./bundles 2-2 嵌入原生项目 把打包出来的jsbundle及assets复制到项目根目录 更改入口文件 123456789101112-(void)initRNView &#123; NSURL *jsCodeLocation; jsCodeLocation = [[NSBundle mainBundle] URLForResource:@\"main\" withExtension:@\"jsbundle\"]; RCTRootView *rootView = [[RCTRootView alloc] initWithBundleURL:jsCodeLocation moduleName:@\"JucaiApp\" initialProperties:nil launchOptions:nil]; CGRect rect = [[UIScreen mainScreen] bounds]; rootView.frame = CGRectMake(0, 0, rect.size.width, rect.size.height); [self.view addSubview:rootView];&#125;===&gt; 同样注意程序入口名称JucaiApp 注：如果遇到确实某个RN项目package.json中配置的第三方依赖模块缺失，则需要在手动加到现有原生项目中(podfile维护即可)，但正常情况下是不需要滴. 差一个目录的截图 Android原生混和开发：一、开发配置 创建package.json 文件并npm install 1234567dependencies &#123; compile &quot;com.facebook.react:react-native:+&quot; compile &apos;com.android.support:appcompat-v7:23.4.0&apos; compile fileTree(dir: &quot;libs&quot;, include: [&quot;*.jar&quot;]) compile project(&apos;:@remobile/react-native-toast&apos;)&#125;==&gt; 要用的库这样加进去,也可以Open Model Setting 添加依赖 MainApplication 实现 ReactApplication并重载相关方法 12345678//facebook/react/ReactNativeHost.javaprotected String getJSMainModuleName() &#123; return \"index.android\";&#125;protected @Nullable String getBundleAssetName() &#123; return \"index.android.bundle\";&#125;==&gt; 0.28or0.29以后就默认情况下就会默认设定加载，具体可参考ReactNativeHost.java build.gradle 添加设置node_modules的路径 12345678910allprojects &#123; repositories &#123; mavenLocal() jcenter() maven &#123; // All of React Native (JS, Obj-C sources, Android binaries) is installed from npm url &quot;$rootDir/../node_modules/react-native/android&quot; &#125; &#125;&#125; 暂未做在混合开发中配置RN DEBUG 方式，可以查看ReactNativeHost.java 配置即可 二、开始开发2-1 创建index.android.js 如果入口文件配置OK则就可看到RN开发页面了. 同样，用RN开发的模块应该放在单独的目录中. 集成已有RN模块(jsbundle)：一、开发配置 同样和IOS配置一样，这里需要android项目搭建好基本的RN开发环境 二、开始开发2-1 打包jsbundle及资源文件打包命令：1react-native bundle android --entry-file index.android.js --bundle-output ./bundles/index.android.bundle.js --assets-dest ./bundles --dev false 同样，打包完毕后会有一些图片的资源文件夹，直接复制到res目录中 Markdown 2-2 配置加载的jsbundle1234@Overrideprotected String getBundleAssetName()&#123; return &quot;main.jsbundle&quot;;&#125; 到此，原生中集成RN开发流程就完成啦！ 参考项目后面会做","categories":[{"name":"前端开发","slug":"前端开发","permalink":"http://yoursite.com/categories/前端开发/"}],"tags":[{"name":"react-native","slug":"react-native","permalink":"http://yoursite.com/tags/react-native/"}]}]}